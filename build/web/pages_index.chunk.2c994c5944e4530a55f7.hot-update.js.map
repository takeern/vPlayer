{"version":3,"file":"pages_index.chunk.2c994c5944e4530a55f7.hot-update.js","sources":["webpack:///./src/player/decode/video.ts"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst libffmpeg = require('../../../lib/libffmpeg.txt').default;\nconst libffmpegWorker = require('../../../lib/libffmpeg.worker.txt').default;\nconst createJavaScriptUrl = (code) => {\n    return URL.createObjectURL(new Blob([code], {\n        type: 'application/javascript'\n    }));\n};\nconst wasmPath = () => {\n    const orgin = location.origin;\n    if (orgin.indexOf('127.0.0.1') > -1 || orgin.indexOf('localhost') > -1) {\n        return 'http://127.0.0.1:8083';\n    }\n    return orgin;\n};\nimport { NalUnitType } from \"../constants\";\nimport Utils from \"../utils\";\nexport default class VideoDecoder {\n    constructor(option) {\n        this.option = option;\n        this.state = {\n            decoding: false,\n            lastSendPts: null,\n            flushing: false,\n            // appendCount: 0,\n            reslove: null,\n            init: false,\n            minTimeline: 0,\n            initCb: null\n        };\n        this.performanceState = {\n            appendDataTime: {},\n            lastRecieveTime: null,\n            count: 0,\n            seekTime: 0,\n            drapCount: 0\n        };\n        this.init();\n        this.bindEvent();\n    }\n    init() {\n        this.loadWasm();\n    }\n    loadWasm() {\n        const mainScriptUrl = createJavaScriptUrl(libffmpeg);\n        const workerScriptUrl = createJavaScriptUrl(libffmpegWorker);\n        self.importScripts(mainScriptUrl);\n        self['WASMDecoder']({\n            mainScriptUrlOrBlob: mainScriptUrl,\n            locateFile: (wasm) => {\n                if (wasm.indexOf('worker.js') > -1) {\n                    return workerScriptUrl;\n                }\n                else {\n                    return wasmPath() + '/' + wasm;\n                }\n            }\n        }).then(instance => {\n            this.instance = instance;\n            this.handleModuleInit();\n        });\n    }\n    /**\n     * worker 消息处理时，考虑到消息队列被阻塞，导致新消息需要等很久才能解析。\n     */\n    bindEvent() { }\n    handleModuleInit() {\n        // decode \n        this.initDecode();\n        this.state.init = true;\n    }\n    handleGetFrame(addr_y, addr_u, addr_v, stride_y, stride_u, stride_v, width, height, pts, decodeTime) {\n        const out_y = this.instance.HEAPU8.subarray(addr_y, addr_y + stride_y * height);\n        const out_u = this.instance.HEAPU8.subarray(addr_u, addr_u + stride_u * height / 2);\n        const out_v = this.instance.HEAPU8.subarray(addr_v, addr_v + stride_v * height / 2);\n        const obj = {\n            stride_y,\n            stride_u,\n            stride_v,\n            width,\n            height,\n            buf_y: new Uint8Array(out_y),\n            buf_u: new Uint8Array(out_u),\n            buf_v: new Uint8Array(out_v),\n            pts\n        };\n        const renderTime = pts * this.option.baseTime;\n        if (this.state.lastSendPts && pts <= this.state.lastSendPts) { // debugger;\n        }\n        this.state.lastSendPts = pts;\n        if (this.state.minTimeline) {\n            if (renderTime < this.state.minTimeline) {\n                // console.log('丢弃无用视频帧', renderTime, this.state.minTimeline);\n                return;\n            }\n            else {\n                this.state.minTimeline = null;\n            }\n        } // console.log('收到解码帧 pts: %f, renderTime: %f, ', obj.pts, renderTime, obj.buf_u.buffer, obj.buf_y.buffer, obj.buf_v.buffer)\n        this.option.handleDecodeRecieve(Object.assign(Object.assign({}, obj), { decodeTime,\n            renderTime }));\n    }\n    initDecode() {\n        const cb = this.instance.addFunction(this.handleGetFrame.bind(this), 'viiiiiiiiii');\n        this.instance._init_decoder(cb, 0, 1); // this.state.flushing = false;\n        this.state.init = true;\n        if (this.state.reslove) {\n            this.state.reslove();\n            this.state.initCb && this.state.initCb();\n            this.state.reslove = null;\n            this.state.initCb = null;\n        }\n    }\n    decodeData(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise(resolve => {\n                if (this.state.init) {\n                    this.state.decoding = true;\n                    const { PTS, data_byte } = data;\n                    if (this.performanceState.seekTime) {\n                        if (this.state.minTimeline > PTS * this.option.baseTime) {\n                            this.performanceState.count++;\n                        }\n                        else {\n                            const { count, drapCount, seekTime } = this.performanceState;\n                            const useTime = performance.now() - seekTime;\n                            Utils.log('seekend', useTime, count, useTime / (count - drapCount), drapCount);\n                            this.performanceState.count = 0;\n                            this.performanceState.seekTime = 0;\n                            this.performanceState.drapCount = 0;\n                        }\n                    }\n                    if (this.option.seekDropFrame && this.state.minTimeline > PTS * this.option.baseTime && this.isUnusePkt(data_byte)) {\n                        // 如果处于seek 情况下，跳过非关键帧的解码;\n                        this.performanceState.drapCount++;\n                    }\n                    else {\n                        // this.state.lastSendPts = PTS;\n                        if (self.nodecode) {\n                            return;\n                        } // console.log('发送解码pak, pts: %f, rendTime: %.2f, len: %f', PTS, parseFloat((PTS / 90000).toFixed(2)), data_byte.byteLength, data_byte.buffer);\n                        const fileSize = data_byte.length;\n                        const ptr = this.instance._malloc(fileSize);\n                        this.instance.HEAPU8.set(data_byte, ptr); // console.log('get pakcent', data, PTS, data.DTS);\n                        this.instance._decode_buffer(ptr, fileSize, PTS);\n                        this.instance._free(ptr);\n                        this.state.reslove = null; // 因为解码是同步过程，此处将cpu 丢给其他函数使用\n                    }\n                    if (!this.state.init) {\n                        this.state.reslove = resolve;\n                        return;\n                    }\n                    setTimeout(() => {\n                        resolve();\n                    }, 0);\n                }\n                else {\n                    this.state.reslove = resolve;\n                    this.state.initCb = () => {\n                        this.decodeData(data);\n                    };\n                }\n            });\n        });\n    }\n    flushDecode() {\n        // this.state.flushing = true;\n        this.instance._flush_decoder();\n    }\n    seek(time) {\n        this.flushDecode();\n        this.state.minTimeline = time;\n        this.performanceState.seekTime = performance.now();\n    }\n    closeDecode() {\n        this.instance._close_decoder();\n        this.state.init = false;\n    }\n    isUnusePkt(bf) {\n        const view = new Uint8Array(bf);\n        for (let i = 4; i < view.length; i++) {\n            if (view[i - 1] === 1 && view[i - 2] === 0 && view[i - 3] === 0 && view[i - 4] === 0) {\n                const unitType = view[i] >> 1;\n                if (NalUnitType[unitType])\n                    return true;\n            }\n        }\n        return false;\n    }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AADA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;;;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AATA;AAWA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAWA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AAAA;AACA;AADA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAFA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAjDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkDA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;;;;;;;;A","sourceRoot":""}